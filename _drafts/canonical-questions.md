I've built APIs, client libraries, and data pipelines in Python. I'm proficient with the language and standard libraries. I have experience using libraries for data manipulation and machine learning. My roles have focused on providing engineering support for machine learning and biomedical research teams.

I like building tools that allow other engineers, data scientists, and subject-matter experts leverage their own skills. I've benefitted greatly from tools Canonical has provided and I'd love the opportunity to make a contribution.

I've deployed code to various flavors of Unix for most of my career. I've learned as-needed enough to provision a machine for development or to host production code. Ubuntu and Apt make this easy. In a professional environment, I'd typically collaborate with dedicated ops, cloud, and security engineers.

I built a good part of the Python client library for Sage Synapse, a data sharing platform for biomedical researchers. During my involvement, we were proud to have the highest level of outside contribution of any project in the company. I helped to onboard and train the very capable hands it's in today.

With Sage Bionetworks, I helped run community data analysis challenges with academic and industry partners. This involved forming and coordinating distributed teams and working in public.



----

Education

We consider academic results in high school and university for all roles, regardless of seniority or department. To enjoy a long and varied career at Canonical, one would need to tackle problems that cannot be defined today! From engineering to marketing to operations and sales, we intensely value colleagues who are able to puzzle through difficult problems and find the optimal path forward. 

How did you rank in your high school, in your final year in maths and hard sciences? Which was your strongest?
How did you rank in your high school, in your final year in languages and the arts? Which was your strongest?
Please state your high school graduation results or university entrance results, along with the system used, and how to understand those. For example, in the US, you might give your SAT or ACT scores. In Germany, you might give your scores 1-5.
What sort of high school student were you? Outside of class, what were your interests and hobbies?  What would your high school peers remember you for, if we asked them?
Which university and degree did you choose? What other universities did you consider, and why did you select that one?
At university, did you do particularly well at any area of your degree?
Overall, what was your degree result and how did that reflect on your ability?
In high school and university, what did you achieve that was exceptional?
What leadership roles did you take on during your education?


Context

Describe your experience building and maintaining a popular, preferably open-source, library with many users
Describe your experience with software operations and running services in production
How would you approach the design and implementation of new features for such a production service?
Give details of your practical experience with Kubernetes, and with container-based operations in general
We have teams building operators for data platform technology (databases, caches, event queues), observability tools and ML tools (Kubeflow, MLFlow) - describe in detail any relevant experience you have in these areas
Why do you most want to work for Canonical?


Engineering Experience

What kinds of software projects have you worked on before? Which operating systems, development environments, languages, databases?
Give details of your Python software development experience to date, how would you rate your competency with Python?
Give details of your Go software development experience to date, how would you rate your competency with Go?
Which project or piece of software are you most proud of, and why?
Give details of any experience you have with automated provisioning tools, configuration management and infrastructure-as-code tools
How comprehensive is your knowledge of Linux, from the kernel up? How familiar are you with low-level system architecture, runtimes, packaging and command line tooling?
Describe your experience with public cloud based operations - how well do you understand large-scale public cloud estate management and developer experience?
Outline your thoughts on quality in software development. What practices have you found effective to drive improvements in quality? What common practices have you found the least useful?
Outline your thoughts on documentation in software projects. What practices have you followed, what do you think about its impact, and what would you do differently?

----

Education

My first year of high school and the preceeding three years of middle school were at the American School of the Hague in the Netherlands. The adventure of living overseas suited me quite well â€“ the next two years in a buttoned-down New England suburb much less so. I was placed in accelerated math and did reasonably well on the SAT, with percentiles in the 90's in both categories. My last year was at a high school in a Philadelphia suburb. Going to three different high schools is something I don't recommend. In those days, I was mostly interested in skateboarding, reading science fiction, and listening to bands that would make your lawn die. I taught myself to program on Apple IIs. Really, not much has changed.

University was altogether a happier experience, mostly due to the freedom to choose your own path, sometimes known as the major-of-the-month club. I took CS courses throughout. Led by curiousity, I dug into biology and economics, and dabbled in math and English.

The best thing I did as an undergrad was to work in a plant molecular biology lab. I painted tiny dots on cucumber seedlings, wrote data analysis scripts, and watched droplets of purified protein solution flow off the end of a liquid chromatography device. That was a time when technology was giving scientists new powers to inspect individual parts of biological machinery.

I later earned a Master's degree in CS from University of Washington (3.8/4), and continued learning through a pile of online courses and wide reading with no plans to stop.


Context

I've spent a big part of my working life, so far, building software for biomedical applications in research and healthcare contexts. I've found particular satisfaction in building tools that leverage the abilities of deep experts in medicine, genomics, and statistics.

The Institute for Systems Biology and Sage Bioinformatics were both explicitly open-source environments. I built tools for integrating genomics data and for open data and open science. During my time at Sage, I was the lead developer of the Python client library for the Synapse data sharing platform. I was proud of having the highest level of outside contribution of any project at the company. The API documentation for this project is still largely as I left it (search for "Synapse Python Client docs"). Bring in code, feature requests, and sometimes critical feedback from the community was, at times, contentious, but made our offerings stronger and more respected.

In different roles, I've built APIs that provided back-end CRUD operations or access to machine-learning models, following a dev-ops model. Docker has played a big role. I've deployed to several flavors of Unix, AWS Elastic Container Service, Lambda, Azure Functions, and Aptible (managed container hosting) with varying degrees of ops support. I've also provided infrastructure support for researchers running Jupyter notebooks and R-Studio on AWS. I've yet to do more that scratch the surface with Kubernetes.

As a member of the target audience, I appreciate Canonical's work towards automating application management. Application developers should focus on software engineering and domain knowledge. Managing a compute cluster can't be their job unless it becomes much easier.

The ability of an open approach to create value has, by this point, been well demonstrated. I'm a long-time believer. For years, I've benefited from tools like Ubuntu and Apt and would love the chance to make my own contribution.


Engineering Experience

Java taught me lot of software engineering - modularity, concurrency, algorithms, and design patterns - but in the end it started to feel limiting. As my roles shifted to providing engineering support for biomedical researchers and machine learning teams, I adopted the native tools in those areas and moved first to R then Python, with a few interesting side-trips through Lisp-family and typed-functional languages. SQL has been a constant throughout.

I've settled on Python for several years now. I appreciate its pragmatic foundations and the "less is more" approach of a few abstractions that compose well. Also, the depth of libraries for all purposes, especially data manipulation and machine learning is hard to beat. I feel like I have a good grasp of the Python data model and can confidently write tasteful idiomatic code. Go is a great complement to Python. I've only done the beginner tutorial, but would be eager to learn more.

I've deployed code to various flavors of Unix for most of my career.  I've learned as-needed enough to provision a machine for development or to host production code. Ubuntu and Apt make this easy. For cloud deployment, I've worked with Terraform, CloudFormation, and CDK, at a productive beginner level. In a professional environment, I've typically collaborated with dedicated ops, cloud, and security engineers.

I've tried not spent much time on the fads related to engineering process, instead slowly collecting good engineering practices that I've found to make a concrete difference. Automated testing, CI/CD, logging/monitoring and interaction with users are the practices I've found most helpful.

Automated testing is fast, repeatable, and reliable, in contrast to manual testing which is none of those. Where code has external dependencies, I prefer integration tests to mocking, as the wrong assumptions you made when writing the code will likely also be baked into the mock. When fixing a bug, I like to first write the test, watch it fail, then write the fix, and finally watch it turn green. Writing tests this way prevents regression and concentrates testing effort on bug-prone parts of the code.

Automated CI/CD enables rapid iteration on incremental changes, keeping feedback loops tight and limiting the scope of any particular change. The ability to deploy continuously puts features in user's hands sooner, which means bugs get found and fixed quicker. Each iteration of the cycle is an opportunity for course correction.

Logging and monitoring provide the means to observe errors, latency, and usage patterns, which helps find issues and prioritize work.

Direct access to users is something I've highly valued. Sitting with medical doctors, molecular biologists, or other users and watching them work gives insights that are hard to come by any other way. There's nothing quite as motivating when you get it wrong and satisfying when you get it right as direct feedback from users.

Code review, done well, is a vehicle for knowledge transfer. I'm not a fan of fighting style wars or pointless gatekeeping, but good code review can go deeper than "LGTM" to help a team form a shared vision and build a unified product.

Writing good docs, like all writing, pushes you to clarify your thinking. Thinking from the perspective of the reader/user encourages minimizing cognitive load and using abstractions at level above implementation details. One of my favorite examples is the documentation for scikit-learn. The clarity of the library its documentation comes from a deeply thought out representation of machine learning concepts. They present terse API docs, a user's guide full of examples, and tutorials rich in subject matter.


Through lines

While I can't say I planned it, the through lines are clear enough. I've traded my skateboard for a mountain bike. A bit of history has made its way into my reading. I listen to more piano now than crunchy guitar. My family and I are living in New Zealand, in large part to give my kids a similar overseas experience to the one I had living in the Netherlands.

I'm still curious, still learning, still love building. I feel lucky to have a tiny part in a golden age of technology. I'm still captivated by trying to understand complex systems whether a cell, the economy, or a technological system. Technology is a great place for a curious person as there's always more to learn.

Working with Canonical would be a great opportunity for me to join a community of experts with a commitment to openness and quality engineering.
